---
title: Inference with Raster Spatial Data with R
author: 'Bas Machielsen'
date: '2023-05-03'
excerpt: An example demonstration of working with raster data in R. 
slug: []
categories: []
tags: []
---

<script src="{{< blogdown/postref >}}index_files/kePrint/kePrint.js"></script>
<link href="{{< blogdown/postref >}}index_files/lightable/lightable.css" rel="stylesheet" />


<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In this blog post, I want to demonstrate how to work with spatial raster data in R. I already have a couple of tutorials on vector data, but in this blog post, I want to focus exclusively on raster data. I’ll be replicating a paper about Roman Roads by Dalgaard et al. (2021), which attempts to identify the persistent influence of Roman roads (built in the Roman empire) on later economic development. The basic identification strategy they use is a controlled approach, where the unit of analysis is a 1x1 longitude times latitude area. They compute the Roman road density for each area that falls within the boundaries of the former Roman empire , defined as the % of surface of the pixel covered by a road. In addition, as outcome variables, they compute the nightlight (and population) density for the same areas and related them to each other, subject to many controls. In this tutorial I’ll only focus on the basic set-up, and conclude with a small (uncontrolled) analysis, and compare the coefficient magnitude to theirs.</p>
</div>
<div id="importing-the-data" class="section level2">
<h2>Importing the Data</h2>
<p>First, I load the necessary libraries:</p>
<pre class="r"><code>library(tidyverse); library(sf); library(raster); library(rgdal); library(terra)</code></pre>
<pre><code>## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
## ✔ dplyr     1.1.2     ✔ readr     2.1.4
## ✔ forcats   1.0.0     ✔ stringr   1.5.0
## ✔ ggplot2   3.4.1     ✔ tibble    3.2.1
## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0
## ✔ purrr     1.0.1     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors
## Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
## 
## Loading required package: sp
## 
## 
## Attaching package: &#39;raster&#39;
## 
## 
## The following object is masked from &#39;package:dplyr&#39;:
## 
##     select
## 
## 
## Please note that rgdal will be retired during 2023,
## plan transition to sf/stars/terra functions using GDAL and PROJ
## at your earliest convenience.
## See https://r-spatial.org/r/2022/04/12/evolution.html and https://github.com/r-spatial/evolution
## rgdal: version: 1.6-5, (SVN revision 1199)
## Geospatial Data Abstraction Library extensions to R successfully loaded
## Loaded GDAL runtime: GDAL 3.4.1, released 2021/12/27
## Path to GDAL shared files: /usr/share/gdal
## GDAL binary built with GEOS: TRUE 
## Loaded PROJ runtime: Rel. 8.2.1, January 1st, 2022, [PJ_VERSION: 821]
## Path to PROJ shared files: /home/bas/.local/share/proj:/usr/share/proj
## PROJ CDN enabled: FALSE
## Linking to sp version:1.6-0
## To mute warnings of possible GDAL/OSR exportToProj4() degradation,
## use options(&quot;rgdal_show_exportToProj4_warnings&quot;=&quot;none&quot;) before loading sp or rgdal.
## 
## terra 1.7.18
## 
## 
## Attaching package: &#39;terra&#39;
## 
## 
## The following object is masked from &#39;package:rgdal&#39;:
## 
##     project
## 
## 
## The following object is masked from &#39;package:tidyr&#39;:
## 
##     extract</code></pre>
</div>
<div id="data-sources" class="section level2">
<h2>Data Sources</h2>
<p>I’ll also be using a variety of data sources. Here, I want to give a short overview of the data sources used in the original paper, and alternative data sources, as well as R packages that make it easy to access these data:</p>
<p><strong>Dependent variables</strong>:</p>
<ul>
<li><a href="https://sedac.ciesin.columbia.edu/data/collection/gpw-v4">Gridded Population of the World</a></li>
<li><a href="https://github.com/walshc/nightlights">NOAA Nightlights</a></li>
<li><a href="https://github.com/JakobMie/nightlightstats">Alternative Nightlights package</a></li>
<li><a href="https://eogdata.mines.edu/products/vnl/#annual_v2">Website with Graphical User Interface</a></li>
<li><a href="http://oxrep.classics.ox.ac.uk/databases/mines_database/">The Oxford Roman Economy Project</a>: Data on Settlements in 500AD</li>
<li><code>osmdata</code> R package <a href="https://cran.r-project.org/web/packages/osmdata/vignettes/osmdata.html">Vignette</a>: Data on contemporary roads</li>
</ul>
<p><strong>Miscellaneous data</strong>:</p>
<ul>
<li><a href="https://imperium.ahlfeldt.se/">Digital Atlas of the Roman Empire</a>: used to retrieve <em>Oppidum</em> and Roman settlements through an API Interface</li>
<li><a href="https://projectmercury.eu/datasets/">Other Roman Empire Datasets</a></li>
</ul>
<p><strong>Independent variables</strong>:</p>
<ul>
<li><strong>Major Roman Roads</strong>: From the <code>cawd</code> package:</li>
<li><a href="http://oxrep.classics.ox.ac.uk/databases/mines_database/">The Oxford Roman Economy Project</a>: Data on Roman Mines</li>
<li><a href="https://diegopuga.org/data/rugged/">Terrain ruggedness</a></li>
<li><code>elevatr</code> R package <a href="https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html#Get_Raster_Elevation_Data">Vignette</a>: Elevation data through R</li>
<li><a href="https://ozak.github.io/Caloric-Suitability-Index/">Caloric Suitability Index</a>:</li>
<li><a href="https://cran.r-project.org/web/packages/ALUES/index.html">Agricultural Suitability</a>: Agricultural Land Use Evaluation System</li>
<li><a href="https://rpubs.com/ials2un/trrclmt">The <code>climateR</code> package</a>: Package with access to climate data</li>
<li><a href="https://agrdatasci.github.io/climatrends/">The <code>climatrends</code> package</a>: Alternative package with access to climate data</li>
</ul>
</div>
<div id="get-the-roads-and-the-borders" class="section level2">
<h2>Get the roads and the borders</h2>
<ul>
<li>The borders can be found on <a href="https://github.com/AWMC/geodata/blob/master/Cultural-Data/political_shading/roman_empire_ce_117_extent/roman_empire_ce_117_extent.geojson">this repository</a>. I’ll be using only a small subset of the data to keep down computational and memory load.</li>
</ul>
<pre class="r"><code>links &lt;- &#39;https://raw.githubusercontent.com/AWMC/geodata/master/Cultural-Data/political_shading/roman_empire_ce_117_extent/roman_empire_ce_117_extent.geojson&#39;
download.file(links, destfile=&#39;roman_empire.geojson&#39;)

borders &lt;- sf::st_read(&#39;./roman_empire.geojson&#39;)|&gt; st_as_sf()</code></pre>
<pre><code>## Reading layer `roman_empire&#39; from data source 
##   `/home/bas/Documents/git/new_website/content/blog/2023-05-03-inference-with-raster-spatial-data-with-r/roman_empire.geojson&#39; 
##   using driver `GeoJSON&#39;
## Simple feature collection with 112 features and 8 fields
## Geometry type: POLYGON
## Dimension:     XY
## Bounding box:  xmin: -9.48732 ymin: 22.89549 xmax: 43.75164 ymax: 55.16792
## Geodetic CRS:  WGS 84</code></pre>
<pre class="r"><code># filtered version to make the data computable
borders &lt;- borders |&gt; filter(OBJECTID &lt; 18)
roads &lt;- cawd::darmc.roman.roads.major.sp |&gt; st_as_sf()

numbers &lt;- st_intersects(roads, borders) |&gt; 
  as.data.frame() |&gt; 
  dplyr::select(row.id) |&gt; 
  pull() |&gt; 
  unique()

roads &lt;- roads |&gt; filter(is.element(row_number(), numbers))</code></pre>
<pre class="r"><code>ggplot() + geom_sf(data=borders) + 
  geom_sf(data=roads, color=&#39;blue&#39;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/plot_borders-1.png" width="672" /></p>
</div>
<div id="import-and-filter-nightlight-density" class="section level2">
<h2>Import and filter nightlight density</h2>
<ul>
<li>The following has to be run only once to recreate the nightlights data.</li>
</ul>
<pre class="r"><code># load the raster dataset
raster_data &lt;- raster(&quot;./nightlights/VNL_v21_npp_2014_global_vcmslcfg_c202205302300.average_masked.dat.tif&quot;)
# Crop the dataset:
raster_data &lt;- crop(x = raster_data, y = borders)
# Or
#raster_data &lt;- crop(x = raster_data, y = extent(borders))

# Limit the max light intensity
raster_data &lt;- raster_data |&gt; clamp(upper = 50)
# Crop the data:
#raster_data &lt;- raster::mask(raster_data, 
#                                 mask = as_Spatial(st_bbox(borders) |&gt; st_as_sfc()))
# Or:
raster_data &lt;- raster::mask(raster_data ,mask=borders)

# Write output
writeRaster(raster_data, &quot;./nightlights/nightlights_re.tif&quot;, overwrite=TRUE)</code></pre>
<p>We can now use the imported file:</p>
<pre class="r"><code>raster_data &lt;- raster::raster(&quot;./nightlights/nightlights_re.tif&quot;)
crs &lt;- raster_data@crs</code></pre>
<pre class="r"><code>plot(raster_data, col = gray.colors(100))</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="compute-nightlight-density-per-0.5x0.5" class="section level2">
<h2>Compute nightlight density per 0.5x0.5</h2>
<p>Now, we can set out to compute the nightlight density per 0.5x0.5 latitude x longitude area.</p>
<pre class="r"><code># set the resolution of the grid
resolution &lt;- 0.5
# convert raster to points
raster_points &lt;- raster::rasterToPoints(raster_data)
# round the coordinates to the nearest 0.5 degrees
raster_points[,1:2] &lt;- round(raster_points[,1:2]/resolution)*resolution
# convert to SpatialPointsDataFrame
raster_sp &lt;- sp::SpatialPointsDataFrame(raster_points[,1:2],
                                        data.frame(value=raster_points[,3]))
# compute mean value for each cell
raster_mean &lt;- raster::aggregate(raster_sp, by=list(round(raster_sp@coords[,1]/resolution),
                                                    round(raster_sp@coords[,2]/resolution)), 
                                 FUN=mean)

# convert back to raster
raster_mean_raster_nl &lt;- raster::rasterFromXYZ(data.frame(raster_mean),
                                            crs=raster_data@crs,
                                            res=resolution)</code></pre>
<p>Now our raster looks like this:</p>
<pre class="r"><code>plot(raster_mean_raster_nl$value)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
</div>
<div id="compute-roman-road-density-per-1x1" class="section level2">
<h2>Compute Roman road density per 1x1</h2>
<p>Our next job is to calculate the road density over these same areas. In order to do so, we have to create a buffer around the roads to make sure it has an area. In line with the paper, we’ll pick an area of 5 kilometer:</p>
<pre class="r"><code># create a 5km buffer around the vector dataset
buffer_data &lt;- st_buffer(roads, dist = 5000)
# convert the buffer to a raster dataset
buffer_raster &lt;- rasterize(buffer_data, raster_data, background=0)
# reclassify the buffer_raster
buffer_raster &lt;- reclassify(buffer_raster, 
                            matrix(c(0.001, 10000, 1), 
                                   ncol=3, byrow = TRUE)) 

# mask the buffer to be zero only if inside the empire borders but without road
buffer_raster &lt;- mask(buffer_raster, mask = raster_data) 

# convert raster to points
raster_points &lt;- raster::rasterToPoints(buffer_raster)</code></pre>
<p>Now that we have the rasterized buffered roads data, we can aggregate it by 0.5x0.5 latitude x longitude area, and calculate the percentage of area covered by roman road. We reclassified the area such that roads have a value of 1 at a pixel where there is a road, 0 otherwise. Because of this, we can calculate the density by taking the mean per area.</p>
<pre class="r"><code># round the coordinates to the nearest 0.5 degrees
raster_points[,1:2] &lt;- round(raster_points[,1:2]/resolution)*resolution
# convert to SpatialPointsDataFrame
raster_sp &lt;- sp::SpatialPointsDataFrame(raster_points[,1:2],
                                        data.frame(value=raster_points[,3]))

# compute mean value for each cell
raster_mean &lt;- raster::aggregate(raster_sp, by=list(round(raster_sp@coords[,1]/resolution),
                                                    round(raster_sp@coords[,2]/resolution)), 
                                 FUN=mean)</code></pre>
<p>Finally, we put this mean per area back into a raster and plot:</p>
<pre class="r"><code># convert back to raster
raster_mean_raster_roads &lt;- raster::rasterFromXYZ(data.frame(raster_mean),
                                            crs=crs,
                                            res=resolution)</code></pre>
<pre class="r"><code>plot(raster_mean_raster_roads$value)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="analysis" class="section level2">
<h2>Analysis</h2>
<p>The analysis now involves stacking the data from <code>raster_mean_raster_nl</code> (the nightlights data) and <code>raster_mean_raster_roads</code> involving the roads and regression the one on the other. Let’s implement this and then conduct a short analysis. The relevant data is in the fourth column of the raster data.</p>
<pre class="r"><code>data &lt;- data.frame(
  nightlights = raster_mean_raster_nl@data@values[,4],
  roads = raster_mean_raster_roads@data@values[,4])</code></pre>
<pre class="r"><code>library(fixest); library(modelsummary)

fixest::feols(nightlights ~ log(1+roads), data = data) |&gt;
  msummary(stars = T, vcov = &#39;robust&#39;)</code></pre>
<table style="NAborder-bottom: 0; width: auto !important; margin-left: auto; margin-right: auto;" class="table">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:center;">
 (1)
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:center;">
1.030***
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:center;">
(0.239)
</td>
</tr>
<tr>
<td style="text-align:left;">
log(1 + roads)
</td>
<td style="text-align:center;">
5.061***
</td>
</tr>
<tr>
<td style="text-align:left;box-shadow: 0px 1px">
</td>
<td style="text-align:center;box-shadow: 0px 1px">
(1.062)
</td>
</tr>
<tr>
<td style="text-align:left;">
Num.Obs.
</td>
<td style="text-align:center;">
687
</td>
</tr>
<tr>
<td style="text-align:left;">
R2
</td>
<td style="text-align:center;">
0.066
</td>
</tr>
<tr>
<td style="text-align:left;">
R2 Adj.
</td>
<td style="text-align:center;">
0.065
</td>
</tr>
<tr>
<td style="text-align:left;">
AIC
</td>
<td style="text-align:center;">
3624.8
</td>
</tr>
<tr>
<td style="text-align:left;">
BIC
</td>
<td style="text-align:center;">
3633.9
</td>
</tr>
<tr>
<td style="text-align:left;">
RMSE
</td>
<td style="text-align:center;">
3.37
</td>
</tr>
<tr>
<td style="text-align:left;">
Std.Errors
</td>
<td style="text-align:center;">
HC1
</td>
</tr>
</tbody>
<tfoot>
<tr>
<td style="padding: 0; " colspan="100%">
<sup></sup> + p &lt; 0.1, * p &lt; 0.05, ** p &lt; 0.01, *** p &lt; 0.001
</td>
</tr>
</tfoot>
</table>
</div>
